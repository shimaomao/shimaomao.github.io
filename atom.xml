<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云淡风轻</title>
  <subtitle>迈向架构</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shimaomao.info/"/>
  <updated>2016-02-19T01:46:08.349Z</updated>
  <id>http://shimaomao.info/</id>
  
  <author>
    <name>shimaomao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>传统的BIO编程</title>
    <link href="http://shimaomao.info/2015/09/02/%E4%BC%A0%E7%BB%9F%E7%9A%84BIO%E7%BC%96%E7%A8%8B/"/>
    <id>http://shimaomao.info/2015/09/02/传统的BIO编程/</id>
    <published>2015-09-02T02:23:00.000Z</published>
    <updated>2016-02-19T01:46:08.349Z</updated>
    
    <content type="html">&lt;p&gt;网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过网络套接字（Socket）进行通信。&lt;/p&gt;
&lt;p&gt;在基于传统同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口，Socket负责发起连接操作，连接成功之后，双方通过输入和输出流进行同步阻塞式通信。&lt;/p&gt;
&lt;p&gt;下面，我们就以经典的时间服务器（TimeServer）为例，通过代码分析来回顾和熟悉下BIO编程。&lt;/p&gt;
&lt;h3 id=&quot;BIO通信模型图&quot;&gt;&lt;a href=&quot;#BIO通信模型图&quot; class=&quot;headerlink&quot; title=&quot;BIO通信模型图&quot;&gt;&lt;/a&gt;BIO通信模型图&lt;/h3&gt;&lt;p&gt;首先，我们通过下面的通信模型图来熟悉下BIO的服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的一请求一应答通信模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ifeve.com/wp-content/uploads/2014/05/bio-image.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;            同步阻塞IO服务端通信模型（一客户端一线程）&lt;/p&gt;
&lt;p&gt;该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1：1的正比关系，由于线程是JAVA虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问量的继续增大，系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务。&lt;/p&gt;
&lt;h3 id=&quot;同步阻塞式IO创建的TimeServer源码分析&quot;&gt;&lt;a href=&quot;#同步阻塞式IO创建的TimeServer源码分析&quot; class=&quot;headerlink&quot; title=&quot;同步阻塞式IO创建的TimeServer源码分析&quot;&gt;&lt;/a&gt;同步阻塞式IO创建的TimeServer源码分析&lt;/h3&gt;&lt;p&gt;同步阻塞IO的TimeServer：&lt;/p&gt;
&lt;p&gt;public class TimeServer {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
    int port = 8080;
    if (args != null &amp;amp;&amp;amp; args.length &amp;gt; 0) {

        try {
        port = Integer.valueOf(args[0]);
        } catch (NumberFormatException e) {
        // 采用默认值
        }

    }
     ServerSocket server = null;
    try {
        server = new ServerSocket(port);
        System.out.println(&amp;quot;The time server is start in port : &amp;quot; + port);
        Socket socket = null;
        while (true) {
        socket = server.accept();
        new Thread(new TimeServerHandler(socket)).start();
        }
    } finally {
        if (server != null) {
        System.out.println(&amp;quot;The time server close&amp;quot;);
        server.close();
        server = null;
        }
    }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;imeServer根据传入的参数设置监听端口，如果没有入参，使用默认值8080，20行通过构造函数创建ServerSocket，如果端口合法且没有被占用，服务端监听成功。23-26行通过一个无限循环来监听客户端的连接，如果没有客户端接入，则主线程阻塞在ServerSocket的accept操作上。启动TimeServer，通过JvisualVM打印线程堆栈，我们可以发现主程序确实阻塞在accept操作上，如下图所示：&lt;br&gt;&lt;img src=&quot;http://ifeve.com/wp-content/uploads/2014/05/main_program_stack.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;主程序线程堆栈&lt;/p&gt;
&lt;p&gt;当有新的客户端接入的时候，执行代码25行，以Socket为参数构造TimeServerHandler对象，TimeServerHandler是一个Runnable，使用它为构造函数的参数创建一个新的客户端线程处理这条Socket链路。下面我们继续分析TimeServerHandler的代码。&lt;/p&gt;
&lt;p&gt;public class TimeServerHandler implements Runnable {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private Socket socket;

public TimeServerHandler(Socket socket) {
this.socket = socket;
}

/*
 * (non-Javadoc)
 *
 * @see java.lang.Runnable#run()
 */
@Override
public void run() {
BufferedReader in = null;
PrintWriter out = null;
try {
    in = new BufferedReader(new InputStreamReader(
        this.socket.getInputStream()));
    out = new PrintWriter(this.socket.getOutputStream(), true);
    String currentTime = null;
    String body = null;
    while (true) {
    body = in.readLine();
    if (body == null)
        break;
    System.out.println(&amp;quot;The time server receive order : &amp;quot; + body);
    currentTime = &amp;quot;QUERY TIME ORDER&amp;quot;.equalsIgnoreCase(body) ? new java.util.Date(
        System.currentTimeMillis()).toString() : &amp;quot;BAD ORDER&amp;quot;;
    out.println(currentTime);
    }

} catch (Exception e) {
    if (in != null) {
    try {
        in.close();
    } catch (IOException e1) {
        e1.printStackTrace();
    }
    }
    if (out != null) {
    out.close();
    out = null;
    }
    if (this.socket != null) {
    try {
        this.socket.close();
    } catch (IOException e1) {
        e1.printStackTrace();
    }
    this.socket = null;
    }
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;25行通过BufferedReader读取一行，如果已经读到了输入流的尾部，则返回值为null，退出循环。如果读到了非空值，则对内容进行判断，如果请求消息为查询时间的指令”QUERY TIME ORDER”则获取当前最新的系统时间，通过PrintWriter的println函数发送给客户端，最后退出循环。代码35-52行释放输入流、输出流、和Socket套接字句柄资源，最后线程自动销毁并被虚拟机回收。&lt;/p&gt;
&lt;p&gt;在下一个小结，我们将介绍同步阻塞IO的客户端代码，然后分别运行服务端和客户端，查看下程序的运行结果。&lt;/p&gt;
&lt;h3 id=&quot;同步阻塞式IO创建的TimeClient源码分析&quot;&gt;&lt;a href=&quot;#同步阻塞式IO创建的TimeClient源码分析&quot; class=&quot;headerlink&quot; title=&quot;同步阻塞式IO创建的TimeClient源码分析&quot;&gt;&lt;/a&gt;同步阻塞式IO创建的TimeClient源码分析&lt;/h3&gt;&lt;p&gt;客户端通过Socket创建，发送查询时间服务器的”QUERY TIME ORDER”指令，然后读取服务端的响应并将结果打印出来，随后关闭连接，释放资源，程序退出执行。&lt;/p&gt;
&lt;p&gt;同步阻塞IO的TimeClient：&lt;/p&gt;
&lt;p&gt;public class TimeClient {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param args
 */
public static void main(String[] args) {
int port = 8080;
if (args != null &amp;amp;&amp;amp; args.length &amp;gt; 0) {
    try {
    port = Integer.valueOf(args[0]);
    } catch (NumberFormatException e) {
    // 采用默认值
    }
}
Socket socket = null;
BufferedReader in = null;
PrintWriter out = null;
try {
    socket = new Socket(&amp;quot;127.0.0.1&amp;quot;, port);
    in = new BufferedReader(new InputStreamReader(
        socket.getInputStream()));
    out = new PrintWriter(socket.getOutputStream(), true);
    out.println(&amp;quot;QUERY TIME ORDER&amp;quot;);
    System.out.println(&amp;quot;Send order 2 server succeed.&amp;quot;);
    String resp = in.readLine();
    System.out.println(&amp;quot;Now is : &amp;quot; + resp);
} catch (Exception e) {
   //不需要处理
} finally {
    if (out != null) {
    out.close();
    out = null;
    }

    if (in != null) {
    try {
        in.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
    in = null;
    }
    if (socket != null) {
    try {
        socket.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
    socket = null;
    }
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;第23行客户端通过PrintWriter向服务端发送”QUERY TIME ORDER”指令，然后通过BufferedReader的readLine读取响应并打印。&lt;/p&gt;
&lt;p&gt;分别执行服务端和客户端，执行结果如下：&lt;/p&gt;
&lt;p&gt;服务端执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ifeve.com/wp-content/uploads/2014/05/block-io-result.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;同步阻塞IO时间服务器服务端运行结果.&lt;/p&gt;
&lt;p&gt;客户端执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ifeve.com/wp-content/uploads/2014/05/block-io-client.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;同步阻塞IO时间服务器客户端运行结果&lt;/p&gt;
&lt;p&gt;到此为止，同步阻塞式IO开发的时间服务器程序已经讲解完毕，我们发现，BIO主要的问题在于每当有一个新的客户端请求接入时，服务端必须创建一个新的线程处理新接入的客户端链路，一个线程只能处理一个客户端连接。在高性能服务器应用领域，往往需要面向成千上万个客户端的并发连接，这种模型显然无法满足高性能、高并发接入的场景。&lt;br&gt; 为了改进一线程一连接模型，后来又演进出了一种通过线程池或者消息队列实现1个或者多个线程处理N个客户端的模型，由于它的底层通信机制依然使用同步阻塞IO，所以被称为 “伪异步”，&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过网络套接字（Socket）进行通信
    
    </summary>
    
    
      <category term="Netty" scheme="http://shimaomao.info/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>关于Netty总结的几个疑问</title>
    <link href="http://shimaomao.info/2015/08/31/netty%E6%80%BB%E7%BB%931/"/>
    <id>http://shimaomao.info/2015/08/31/netty总结1/</id>
    <published>2015-08-31T08:03:00.000Z</published>
    <updated>2016-02-19T01:30:41.532Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Netty是什么？&quot;&gt;&lt;a href=&quot;#Netty是什么？&quot; class=&quot;headerlink&quot; title=&quot;Netty是什么？&quot;&gt;&lt;/a&gt;Netty是什么？&lt;/h2&gt;&lt;p&gt;   Netty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。&lt;/p&gt;
&lt;h2 id=&quot;使用Netty能够做什么？&quot;&gt;&lt;a href=&quot;#使用Netty能够做什么？&quot; class=&quot;headerlink&quot; title=&quot;使用Netty能够做什么？&quot;&gt;&lt;/a&gt;使用Netty能够做什么？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;开发异步、非阻塞的TCP网络应用程序；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;开发异步、非阻塞的UDP网络应用程序；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;开发异步文件传输应用程序；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;开发异步HTTP服务端和客户端应用程序；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;提供对多种编解码框架的集成，包括谷歌的Protobuf、Jbossmarshalling、Java序列化、压缩编解码、XML解码、字符串编解码等，这些编解码框架可以被用户直接使用；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;提供形式多样的编解码基础类库，可以非常方便的实现私有协议栈编解码框架的二次定制和开发；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;基于职责链模式的Pipeline-Handler机制，用户可以非常方便的对网络事件进行拦截和定制；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;所有的IO操作都是异步的，用户可以通过Future-Listener机制主动Get结果或者由IO线程操作完成之后主动Notify结果，用户的业务线程不需要同步等待；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;IP黑白名单控制；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;打印消息码流；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;流量控制和整形；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;性能统计；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;基于链路空闲事件检测的心跳检测&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;为什么要选择Netty框架？&quot;&gt;&lt;a href=&quot;#为什么要选择Netty框架？&quot; class=&quot;headerlink&quot; title=&quot;为什么要选择Netty框架？&quot;&gt;&lt;/a&gt;为什么要选择Netty框架？&lt;/h2&gt;&lt;p&gt;Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro使用Netty作为通信框架。很多其它业界主流的RPC和分布式服务框架，也使用Netty来构建高性能的异步通信能力。&lt;/p&gt;
&lt;p&gt;Netty的优点总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API使用简单，开发门槛低；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;功能强大，预置了多种编解码功能，支持多种主流协议；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它完全满足不同行业的商用标准。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正是因为这些优点，Netty逐渐成为Java NIO编程的首选框架。&lt;/p&gt;
&lt;h2 id=&quot;使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？&quot;&gt;&lt;a href=&quot;#使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？&quot; class=&quot;headerlink&quot; title=&quot;使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？&quot;&gt;&lt;/a&gt;使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？&lt;/h2&gt;&lt;p&gt;传统基于同步阻塞IO（BIO）的线程模型图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ifeve.com/wp-content/uploads/2014/05/bio-image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由上图我们可以看出，传统的同步阻塞IO通信存在如下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程模型存在致命缺陷：一连接一线程的模型导致服务端无法承受大量客户端的并发连接；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;性能差：频繁的线程上下文切换导致CPU利用效率不高；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;可靠性差：由于所有的IO操作都是同步的，所以业务线程只要进行IO操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;采用非阻塞IO（NIO）之后，同步阻塞IO的三个缺陷都将迎刃而解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nio采用Reactor模式，一个Reactor线程聚合一个多路复用器Selector，它可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &amp;lt; 进程可用的最大句柄数）或者M : N (M通常为CPU核数  + 1， N &amp;lt; 进程可用的最大句柄数)；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;由于IO线程总数有限，不会存在频繁的IO线程之间上下文切换和竞争，CPU利用率高；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;所有的IO操作都是异步的，即使业务线程直接进行IO操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于切换到NIO编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用NIO进行通信已经逐渐成为主流。&lt;/p&gt;
&lt;h2 id=&quot;为什么不直接基于JDK的NIO类库编程呢？&quot;&gt;&lt;a href=&quot;#为什么不直接基于JDK的NIO类库编程呢？&quot; class=&quot;headerlink&quot; title=&quot;为什么不直接基于JDK的NIO类库编程呢？&quot;&gt;&lt;/a&gt;为什么不直接基于JDK的NIO类库编程呢？&lt;/h2&gt;&lt;p&gt;JDK NIO服务端和客户端的工作时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/news/66372/201404/141406086971872.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;即便抛开代码和NIO类库复杂性不谈，一个高性能、高可靠性的NIO服务端开发和维护成本都是非常高的，开发者需要具有丰富的NIO编程经验和网络维护经验，很多时候甚至需要通过抓包来定位问题。也许开发出一套NIO程序需要1个月，但是它的稳定很可能需要1年甚至更长的时间，这也就是为什么我不建议直接使用JDK NIO类库进行通信开发的一个重要原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/news/66372/201404/141406086669114.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Netty各版本的API变化比较频繁，我该如何选择版本？&quot;&gt;&lt;a href=&quot;#Netty各版本的API变化比较频繁，我该如何选择版本？&quot; class=&quot;headerlink&quot; title=&quot;Netty各版本的API变化比较频繁，我该如何选择版本？&quot;&gt;&lt;/a&gt;Netty各版本的API变化比较频繁，我该如何选择版本？&lt;/h2&gt;&lt;p&gt;事实上，Netty最大的变更就是3.X系列到4.X/5.X的变更，Netty不仅仅重构了包路径，对于之前一直想改但是考虑到前向兼容性没改的类库进行了优化和修改。这次变更的主要原因是Netty脱离了Jboss独立发展，这对于Netty的长远发展是件好事。&lt;/p&gt;
&lt;p&gt;在我看来，Netty4.X系列版本的架构和API设计更加合理，同时，它提供了更多新的特性。因此，我个人建议用户可以选择4.X系列版本，以免未来升级遇到困难和问题。&lt;/p&gt;
&lt;p&gt;对于已经使用3.X系列版本的用户，如果现有功能已经满足需求，短期内暂时不需要升级。如果需要使用更多新特性和功能，建议在充分评估之后进行升级，这可能需要一些工作量。&lt;/p&gt;
&lt;p&gt;由于Netty5最新版本仍处于测试阶段，从学习和研究角度可以试用一下，Netty5相比于Netty4是前向兼容的，因此，未来用户升级到Netty5会更加容易。&lt;/p&gt;
&lt;h2 id=&quot;Netty使用简单吗？&quot;&gt;&lt;a href=&quot;#Netty使用简单吗？&quot; class=&quot;headerlink&quot; title=&quot;Netty使用简单吗？&quot;&gt;&lt;/a&gt;Netty使用简单吗？&lt;/h2&gt;&lt;p&gt;Netty的基础开发和应用非常简单，开发一个Echo服务端只需要28行代码，开发对应的Echo客户端只需要26行代码！&lt;/p&gt;
&lt;p&gt;但是，如果你要利用它进行私有协议栈开发、HTTP服务端和客户端开发等，仍然需要深入的学习Netty的一些高级类库和功能，了解Netty的设计原理。只有这样，才能恰到好处的使用Netty，为项目和公司带来更大的价值。&lt;/p&gt;
&lt;h2 id=&quot;Netty在哪些行业得到了应用？&quot;&gt;&lt;a href=&quot;#Netty在哪些行业得到了应用？&quot; class=&quot;headerlink&quot; title=&quot;Netty在哪些行业得到了应用？&quot;&gt;&lt;/a&gt;Netty在哪些行业得到了应用？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;互联网行业：随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于Tomcat等Web容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。它的架构图如下：&lt;br&gt;&lt;img src=&quot;http://images.cnitblog.com/news/66372/201404/141403260881350.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中，服务提供者和服务消费者之间，服务提供者、服务消费者和性能统计节点之间使用Netty进行异步/同步通信。&lt;/p&gt;
&lt;p&gt;除了Dubbo之外，淘宝的消息中间件RocketMQ的消息生产者和消息消费者之间，也采用Netty进行高性能、异步通信。&lt;/p&gt;
&lt;p&gt;除了阿里系和淘宝系之外，很多其它的大型互联网公司或者电商内部也已经大量使用Netty构建高性能、分布式的网络服务器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏行业：无论是手游服务端、还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过Netty进行高性能的通信，架构示意图如下：&lt;br&gt;&lt;img src=&quot;http://images.cnitblog.com/news/66372/201404/141405275887431.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;大数据领域：经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨节点通信，它的Netty Service基于Netty框架二次封装实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大数据计算往往采用多个计算节点和一个/N个汇总节点进行分布式部署，各节点之间存在海量的数据交换。由于Netty的综合性能是目前各个成熟NIO框架中最高的，因此，往往会被选中用作大数据各节点间的通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;企业软件：企业和IT集成需要ESB，Netty对多协议支持、私有协议定制的简洁性和高性能是ESB RPC框架的首选通信组件。事实上，很多企业总线厂商会选择Netty作为基础通信组件，用于企业的IT集成。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;通信行业：Netty的异步高性能、高可靠性和高成熟度的优点，使它在通信行业得到了大量的应用。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Netty是什么？&quot;&gt;&lt;a href=&quot;#Netty是什么？&quot; class=&quot;headerlink&quot; title=&quot;Netty是什么？&quot;&gt;&lt;/a&gt;Netty是什么？&lt;/h2&gt;&lt;p&gt;   Netty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是：异步非
    
    </summary>
    
    
      <category term="Netty" scheme="http://shimaomao.info/tags/Netty/"/>
    
  </entry>
  
</feed>
